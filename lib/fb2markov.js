// Generated by CoffeeScript 1.6.3
var getFriends, getInbox, getMessageCount, getThreadID, getThreads, handleFriend, makeQuery, testAPI,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

this.API_LIMIT = 4;

this.SIZE_CONVO = 2;

this.GEN_SIZE = 13;

this.my_name = "";

this.friend_name = "";

testAPI = function() {
  console.log("Welcome!  Fetching your information.... ");
  return FB.api("/me", function(response) {
    return console.log("Good to see you, " + response.name + ".");
  });
};

makeQuery = function(queryText, cb) {
  return FB.api({
    method: "fql.query",
    query: queryText
  }, cb);
};

handleFriend = function() {
  $('ul').empty();
  this.friend_name = $('#search').val();
  console.log("friend's name: " + this.friend_name);
  return getInbox(this.name2id[$('#search').val()]);
};

getFriends = function() {
  var handleFriendList;
  handleFriendList = function(response) {
    var keys, num, pair;
    this.name2id = {};
    keys = [];
    for (num in response) {
      pair = response[num];
      this.name2id[pair["name"]] = pair["uid"];
      keys.push(pair["name"]);
    }
    $('#search').typeahead({
      source: keys
    });
    console.log("results: " + (JSON.stringify(name2id)));
    return $('.friend_selector input').prop("disabled", false);
  };
  return makeQuery("SELECT name, uid FROM user WHERE uid IN 		(SELECT uid1 FROM friend WHERE uid2=me())", handleFriendList);
};

getThreads = function() {
  var handleThreads, threadList;
  threadList = [];
  handleThreads = function(threadList) {
    var id, num, _results;
    _results = [];
    for (num in threadList) {
      id = threadList[num];
      _results.push(threadList.push(id['thread_id']));
    }
    return _results;
  };
  makeQuery("SELECT thread_id FROM thread WHERE folder_id = 0", handleThreads);
  return threadList;
};

getMessageCount = function(thread_id, countCB) {
  var parseCount;
  parseCount = function(messageCount) {
    console.log("messageCount: " + (JSON.stringify(messageCount)));
    return countCB(parseInt(messageCount[0]["message_count"]));
  };
  makeQuery("SELECT message_count FROM thread WHERE 		thread_id = " + thread_id + " LIMIT 1", parseCount);
};

getThreadID = function(user_id, countCB) {
  var handleThreadID;
  handleThreadID = function(id_response) {
    var curr_max, id_obj, index, temp_obj, threads;
    threads = [];
    for (index in id_response) {
      id_obj = id_response[index];
      if (__indexOf.call(threads, id_obj) >= 0) {
        continue;
      }
      threads.push(id_obj);
    }
    curr_max = {
      "thread_id": "",
      "message_count": 0
    };
    for (index in threads) {
      temp_obj = threads[index];
      if (parseInt(temp_obj["message_count"]) > parseInt(curr_max["message_count"])) {
        curr_max = temp_obj;
      }
    }
    return countCB(curr_max["thread_id"], curr_max["message_count"]);
  };
  return makeQuery("SELECT thread_id, message_count FROM thread WHERE thread_id IN 		(SELECT thread_id, message_count FROM thread WHERE folder_id =0)		AND '" + user_id + "' IN recipients", handleThreadID);
};

getInbox = function(targetUser) {
  var messageFetcher;
  messageFetcher = function(thread_id, count) {
    var authors, i, iterationsNeeded, lastMessage, messageContainer, messageInterpretor, randomSegment, segment, segments;
    authors = [];
    messageInterpretor = function(lastResponse) {
      var num, val;
      for (num in lastResponse) {
        val = lastResponse[num];
        if (!messageContainer[val["author_id"]]) {
          authors.push(val["author_id"]);
          console.log("Adding author to container " + val['author_id']);
          messageContainer[val["author_id"]] = [];
        }
        messageContainer[val["author_id"]].push(val["body"]);
      }
    };
    lastMessage = function(lastResponse) {
      var arr, arrIndex, author, curr_author, el_id, i, index, markovEx, messageList, newestGen, num, val, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _results, _results1;
      for (num in lastResponse) {
        val = lastResponse[num];
        if (!messageContainer[val["author_id"]]) {
          authors.push(val["author_id"]);
          console.log("Adding author to container " + val['author_id']);
          messageContainer[val["author_id"]] = [];
        }
        messageContainer[val["author_id"]].push(val["body"]);
      }
      console.log("authors: " + authors);
      messageList = {};
      for (index in authors) {
        author = authors[index];
        messageList[author] = [];
        console.log("text: " + (messageContainer[author].join(" ")));
        markovEx = new markov(messageContainer[author].join(" "), "string", /([.,?"();\-!':â€”^\w]+ )/g);
        _ref1 = (arr = (function() {
          _results = [];
          for (var _j = 0, _ref = this.SIZE_CONVO - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
          return _results;
        }).apply(this));
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arrIndex = _ref1[_i];
          newestGen = markovEx.gen(this.GEN_SIZE);
          i = newestGen.lastIndexOf('.');
          if (i !== -1) {
            newestGen = newestGen.substr(0, i + 1);
          }
          messageList[author].push(newestGen);
          console.log("Doing iter: " + arrIndex + ", messageList: " + messageList[author].length);
        }
      }
      _ref3 = (arr = (function() {
        _results1 = [];
        for (var _l = 0, _ref2 = this.SIZE_CONVO - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; 0 <= _ref2 ? _l++ : _l--){ _results1.push(_l); }
        return _results1;
      }).apply(this));
      for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
        arrIndex = _ref3[_k];
        for (index in authors) {
          author = authors[index];
          if (this.name2id[this.friend_name] === author) {
            curr_author = this.friend_name.split(" ")[0];
            el_id = "other";
          } else {
            curr_author = this.my_name;
            el_id = "me";
          }
          $('.chat').append("						<li class='" + el_id + "'>							<div class='chat_obj'>								<span class='chat_name'>" + curr_author + ":</span>								<span class='chat_content'>" + messageList[author][arrIndex] + "</span>							</div>						</li>						");
        }
      }
    };
    iterationsNeeded = count / 30;
    segments = [];
    i = 0;
    while (i < this.API_LIMIT) {
      randomSegment = Math.floor(Math.random() * iterationsNeeded);
      if (__indexOf.call(segments, randomSegment) < 0) {
        segments.push(randomSegment);
        i += 1;
      }
    }
    messageContainer = {};
    for (i in segments) {
      segment = segments[i];
      if (parseInt(i) === this.API_LIMIT - 1) {
        makeQuery("SELECT thread_id, body, author_id, created_time 					FROM message WHERE thread_id = " + thread_id + " 					ORDER BY created_time ASC LIMIT " + (segment * 30) + "," + ((segment * 30) + 30), lastMessage);
      }
      makeQuery("SELECT thread_id, body, author_id, created_time 				FROM message WHERE thread_id = " + thread_id + " 				ORDER BY created_time ASC LIMIT " + (segment * 30) + "," + ((segment * 30) + 30), messageInterpretor);
    }
  };
  return getThreadID(targetUser, messageFetcher);
};

window.fbAsyncInit = function() {
  var tempCallback;
  FB.init({
    appId: "364959256980832",
    status: true,
    cookie: true,
    xfbml: true
  });
  tempCallback = function() {
    return FB.api("/me/", function(response) {
      this.my_name = response["first_name"];
      return getFriends();
    });
  };
  return FB.Event.subscribe("auth.authResponseChange", function(response) {
    if (response.status === "connected") {
      return tempCallback();
    } else if (response.status === "not_authorized") {
      return FB.login(tempCallback);
    } else {
      return FB.login(tempCallback);
    }
  });
};

(function(d) {
  var id, js, ref;
  js = void 0;
  id = "facebook-jssdk";
  ref = d.getElementsByTagName("script")[0];
  if (d.getElementById(id)) {
    return;
  }
  js = d.createElement("script");
  js.id = id;
  js.async = true;
  js.src = "https://connect.facebook.net/en_US/all.js";
  return ref.parentNode.insertBefore(js, ref);
})(document);
